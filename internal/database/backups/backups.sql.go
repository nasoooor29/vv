// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: backups.sql

package backups

import (
	"context"
	"time"
)

const countActiveSchedules = `-- name: CountActiveSchedules :one
SELECT COUNT(*) FROM backup_schedules WHERE enabled = 1
`

func (q *Queries) CountActiveSchedules(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveSchedules)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBackupJobs = `-- name: CountBackupJobs :one
SELECT COUNT(*) FROM backup_jobs
`

func (q *Queries) CountBackupJobs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBackupJobs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBackupJobsByType = `-- name: CountBackupJobsByType :one
SELECT COUNT(*) FROM backup_jobs WHERE type = ?
`

func (q *Queries) CountBackupJobsByType(ctx context.Context, type_ string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBackupJobsByType, type_)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBackupJob = `-- name: CreateBackupJob :one
INSERT INTO backup_jobs (
    name, type, target_type, target_id, target_name, client_id,
    status, progress, destination, size_bytes, error_message,
    started_at, completed_at, created_by
) VALUES (
    ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?,
    ?, ?, ?
) RETURNING id, name, type, target_type, target_id, target_name, client_id, status, progress, destination, size_bytes, error_message, started_at, completed_at, created_by, created_at
`

type CreateBackupJobParams struct {
	Name         string     `json:"name"`
	Type         string     `json:"type"`
	TargetType   string     `json:"target_type"`
	TargetID     string     `json:"target_id"`
	TargetName   *string    `json:"target_name"`
	ClientID     *string    `json:"client_id"`
	Status       string     `json:"status"`
	Progress     *int64     `json:"progress"`
	Destination  *string    `json:"destination"`
	SizeBytes    *int64     `json:"size_bytes"`
	ErrorMessage *string    `json:"error_message"`
	StartedAt    *time.Time `json:"started_at"`
	CompletedAt  *time.Time `json:"completed_at"`
	CreatedBy    *int64     `json:"created_by"`
}

func (q *Queries) CreateBackupJob(ctx context.Context, arg CreateBackupJobParams) (BackupJob, error) {
	row := q.db.QueryRowContext(ctx, createBackupJob,
		arg.Name,
		arg.Type,
		arg.TargetType,
		arg.TargetID,
		arg.TargetName,
		arg.ClientID,
		arg.Status,
		arg.Progress,
		arg.Destination,
		arg.SizeBytes,
		arg.ErrorMessage,
		arg.StartedAt,
		arg.CompletedAt,
		arg.CreatedBy,
	)
	var i BackupJob
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.TargetType,
		&i.TargetID,
		&i.TargetName,
		&i.ClientID,
		&i.Status,
		&i.Progress,
		&i.Destination,
		&i.SizeBytes,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createBackupSchedule = `-- name: CreateBackupSchedule :one
INSERT INTO backup_schedules (
    name, type, target_type, target_id, target_name, client_id,
    schedule, schedule_time, destination, retention_count, enabled,
    next_run_at, created_by
) VALUES (
    ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?,
    ?, ?
) RETURNING id, name, type, target_type, target_id, target_name, client_id, schedule, schedule_time, destination, retention_count, enabled, last_run_at, next_run_at, last_status, created_by, created_at, updated_at
`

type CreateBackupScheduleParams struct {
	Name           string     `json:"name"`
	Type           string     `json:"type"`
	TargetType     string     `json:"target_type"`
	TargetID       string     `json:"target_id"`
	TargetName     *string    `json:"target_name"`
	ClientID       *string    `json:"client_id"`
	Schedule       string     `json:"schedule"`
	ScheduleTime   *string    `json:"schedule_time"`
	Destination    string     `json:"destination"`
	RetentionCount *int64     `json:"retention_count"`
	Enabled        *int64     `json:"enabled"`
	NextRunAt      *time.Time `json:"next_run_at"`
	CreatedBy      *int64     `json:"created_by"`
}

func (q *Queries) CreateBackupSchedule(ctx context.Context, arg CreateBackupScheduleParams) (BackupSchedule, error) {
	row := q.db.QueryRowContext(ctx, createBackupSchedule,
		arg.Name,
		arg.Type,
		arg.TargetType,
		arg.TargetID,
		arg.TargetName,
		arg.ClientID,
		arg.Schedule,
		arg.ScheduleTime,
		arg.Destination,
		arg.RetentionCount,
		arg.Enabled,
		arg.NextRunAt,
		arg.CreatedBy,
	)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.TargetType,
		&i.TargetID,
		&i.TargetName,
		&i.ClientID,
		&i.Schedule,
		&i.ScheduleTime,
		&i.Destination,
		&i.RetentionCount,
		&i.Enabled,
		&i.LastRunAt,
		&i.NextRunAt,
		&i.LastStatus,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBackupJob = `-- name: DeleteBackupJob :exec
DELETE FROM backup_jobs WHERE id = ?
`

func (q *Queries) DeleteBackupJob(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBackupJob, id)
	return err
}

const deleteBackupSchedule = `-- name: DeleteBackupSchedule :exec
DELETE FROM backup_schedules WHERE id = ?
`

func (q *Queries) DeleteBackupSchedule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBackupSchedule, id)
	return err
}

const disableBackupSchedule = `-- name: DisableBackupSchedule :one
UPDATE backup_schedules
SET enabled = 0, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, type, target_type, target_id, target_name, client_id, schedule, schedule_time, destination, retention_count, enabled, last_run_at, next_run_at, last_status, created_by, created_at, updated_at
`

func (q *Queries) DisableBackupSchedule(ctx context.Context, id int64) (BackupSchedule, error) {
	row := q.db.QueryRowContext(ctx, disableBackupSchedule, id)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.TargetType,
		&i.TargetID,
		&i.TargetName,
		&i.ClientID,
		&i.Schedule,
		&i.ScheduleTime,
		&i.Destination,
		&i.RetentionCount,
		&i.Enabled,
		&i.LastRunAt,
		&i.NextRunAt,
		&i.LastStatus,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const enableBackupSchedule = `-- name: EnableBackupSchedule :one
UPDATE backup_schedules
SET enabled = 1, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, type, target_type, target_id, target_name, client_id, schedule, schedule_time, destination, retention_count, enabled, last_run_at, next_run_at, last_status, created_by, created_at, updated_at
`

func (q *Queries) EnableBackupSchedule(ctx context.Context, id int64) (BackupSchedule, error) {
	row := q.db.QueryRowContext(ctx, enableBackupSchedule, id)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.TargetType,
		&i.TargetID,
		&i.TargetName,
		&i.ClientID,
		&i.Schedule,
		&i.ScheduleTime,
		&i.Destination,
		&i.RetentionCount,
		&i.Enabled,
		&i.LastRunAt,
		&i.NextRunAt,
		&i.LastStatus,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBackupJob = `-- name: GetBackupJob :one
SELECT id, name, type, target_type, target_id, target_name, client_id, status, progress, destination, size_bytes, error_message, started_at, completed_at, created_by, created_at FROM backup_jobs WHERE id = ?
`

func (q *Queries) GetBackupJob(ctx context.Context, id int64) (BackupJob, error) {
	row := q.db.QueryRowContext(ctx, getBackupJob, id)
	var i BackupJob
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.TargetType,
		&i.TargetID,
		&i.TargetName,
		&i.ClientID,
		&i.Status,
		&i.Progress,
		&i.Destination,
		&i.SizeBytes,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getBackupSchedule = `-- name: GetBackupSchedule :one
SELECT id, name, type, target_type, target_id, target_name, client_id, schedule, schedule_time, destination, retention_count, enabled, last_run_at, next_run_at, last_status, created_by, created_at, updated_at FROM backup_schedules WHERE id = ?
`

func (q *Queries) GetBackupSchedule(ctx context.Context, id int64) (BackupSchedule, error) {
	row := q.db.QueryRowContext(ctx, getBackupSchedule, id)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.TargetType,
		&i.TargetID,
		&i.TargetName,
		&i.ClientID,
		&i.Schedule,
		&i.ScheduleTime,
		&i.Destination,
		&i.RetentionCount,
		&i.Enabled,
		&i.LastRunAt,
		&i.NextRunAt,
		&i.LastStatus,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBackupStats = `-- name: GetBackupStats :one
SELECT
    COUNT(*) as total_backups,
    SUM(CASE WHEN type LIKE 'vm_%' THEN 1 ELSE 0 END) as vm_snapshots,
    SUM(CASE WHEN type LIKE 'container_%' THEN 1 ELSE 0 END) as container_backups,
    SUM(CASE WHEN type = 'firewall' THEN 1 ELSE 0 END) as firewall_backups,
    COALESCE(SUM(size_bytes), 0) as total_size_bytes,
    MAX(created_at) as last_backup_at
FROM backup_jobs
WHERE status = 'completed'
`

type GetBackupStatsRow struct {
	TotalBackups     int64       `json:"total_backups"`
	VmSnapshots      *float64    `json:"vm_snapshots"`
	ContainerBackups *float64    `json:"container_backups"`
	FirewallBackups  *float64    `json:"firewall_backups"`
	TotalSizeBytes   interface{} `json:"total_size_bytes"`
	LastBackupAt     interface{} `json:"last_backup_at"`
}

func (q *Queries) GetBackupStats(ctx context.Context) (GetBackupStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getBackupStats)
	var i GetBackupStatsRow
	err := row.Scan(
		&i.TotalBackups,
		&i.VmSnapshots,
		&i.ContainerBackups,
		&i.FirewallBackups,
		&i.TotalSizeBytes,
		&i.LastBackupAt,
	)
	return i, err
}

const listBackupJobs = `-- name: ListBackupJobs :many
SELECT id, name, type, target_type, target_id, target_name, client_id, status, progress, destination, size_bytes, error_message, started_at, completed_at, created_by, created_at FROM backup_jobs
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListBackupJobsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListBackupJobs(ctx context.Context, arg ListBackupJobsParams) ([]BackupJob, error) {
	rows, err := q.db.QueryContext(ctx, listBackupJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupJob
	for rows.Next() {
		var i BackupJob
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.TargetType,
			&i.TargetID,
			&i.TargetName,
			&i.ClientID,
			&i.Status,
			&i.Progress,
			&i.Destination,
			&i.SizeBytes,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBackupJobsByTarget = `-- name: ListBackupJobsByTarget :many
SELECT id, name, type, target_type, target_id, target_name, client_id, status, progress, destination, size_bytes, error_message, started_at, completed_at, created_by, created_at FROM backup_jobs
WHERE target_type = ? AND target_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListBackupJobsByTargetParams struct {
	TargetType string `json:"target_type"`
	TargetID   string `json:"target_id"`
	Limit      int64  `json:"limit"`
	Offset     int64  `json:"offset"`
}

func (q *Queries) ListBackupJobsByTarget(ctx context.Context, arg ListBackupJobsByTargetParams) ([]BackupJob, error) {
	rows, err := q.db.QueryContext(ctx, listBackupJobsByTarget,
		arg.TargetType,
		arg.TargetID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupJob
	for rows.Next() {
		var i BackupJob
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.TargetType,
			&i.TargetID,
			&i.TargetName,
			&i.ClientID,
			&i.Status,
			&i.Progress,
			&i.Destination,
			&i.SizeBytes,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBackupJobsByType = `-- name: ListBackupJobsByType :many
SELECT id, name, type, target_type, target_id, target_name, client_id, status, progress, destination, size_bytes, error_message, started_at, completed_at, created_by, created_at FROM backup_jobs
WHERE type = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListBackupJobsByTypeParams struct {
	Type   string `json:"type"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) ListBackupJobsByType(ctx context.Context, arg ListBackupJobsByTypeParams) ([]BackupJob, error) {
	rows, err := q.db.QueryContext(ctx, listBackupJobsByType, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupJob
	for rows.Next() {
		var i BackupJob
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.TargetType,
			&i.TargetID,
			&i.TargetName,
			&i.ClientID,
			&i.Status,
			&i.Progress,
			&i.Destination,
			&i.SizeBytes,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBackupSchedules = `-- name: ListBackupSchedules :many
SELECT id, name, type, target_type, target_id, target_name, client_id, schedule, schedule_time, destination, retention_count, enabled, last_run_at, next_run_at, last_status, created_by, created_at, updated_at FROM backup_schedules
ORDER BY created_at DESC
`

func (q *Queries) ListBackupSchedules(ctx context.Context) ([]BackupSchedule, error) {
	rows, err := q.db.QueryContext(ctx, listBackupSchedules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupSchedule
	for rows.Next() {
		var i BackupSchedule
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.TargetType,
			&i.TargetID,
			&i.TargetName,
			&i.ClientID,
			&i.Schedule,
			&i.ScheduleTime,
			&i.Destination,
			&i.RetentionCount,
			&i.Enabled,
			&i.LastRunAt,
			&i.NextRunAt,
			&i.LastStatus,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledSchedules = `-- name: ListEnabledSchedules :many
SELECT id, name, type, target_type, target_id, target_name, client_id, schedule, schedule_time, destination, retention_count, enabled, last_run_at, next_run_at, last_status, created_by, created_at, updated_at FROM backup_schedules
WHERE enabled = 1
ORDER BY next_run_at ASC
`

func (q *Queries) ListEnabledSchedules(ctx context.Context) ([]BackupSchedule, error) {
	rows, err := q.db.QueryContext(ctx, listEnabledSchedules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupSchedule
	for rows.Next() {
		var i BackupSchedule
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.TargetType,
			&i.TargetID,
			&i.TargetName,
			&i.ClientID,
			&i.Schedule,
			&i.ScheduleTime,
			&i.Destination,
			&i.RetentionCount,
			&i.Enabled,
			&i.LastRunAt,
			&i.NextRunAt,
			&i.LastStatus,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchedulesDueForRun = `-- name: ListSchedulesDueForRun :many
SELECT id, name, type, target_type, target_id, target_name, client_id, schedule, schedule_time, destination, retention_count, enabled, last_run_at, next_run_at, last_status, created_by, created_at, updated_at FROM backup_schedules
WHERE enabled = 1 AND next_run_at <= ?
ORDER BY next_run_at ASC
`

func (q *Queries) ListSchedulesDueForRun(ctx context.Context, nextRunAt *time.Time) ([]BackupSchedule, error) {
	rows, err := q.db.QueryContext(ctx, listSchedulesDueForRun, nextRunAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BackupSchedule
	for rows.Next() {
		var i BackupSchedule
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.TargetType,
			&i.TargetID,
			&i.TargetName,
			&i.ClientID,
			&i.Schedule,
			&i.ScheduleTime,
			&i.Destination,
			&i.RetentionCount,
			&i.Enabled,
			&i.LastRunAt,
			&i.NextRunAt,
			&i.LastStatus,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBackupJobCompleted = `-- name: UpdateBackupJobCompleted :one
UPDATE backup_jobs
SET status = 'completed', progress = 100, completed_at = ?, size_bytes = ?
WHERE id = ?
RETURNING id, name, type, target_type, target_id, target_name, client_id, status, progress, destination, size_bytes, error_message, started_at, completed_at, created_by, created_at
`

type UpdateBackupJobCompletedParams struct {
	CompletedAt *time.Time `json:"completed_at"`
	SizeBytes   *int64     `json:"size_bytes"`
	ID          int64      `json:"id"`
}

func (q *Queries) UpdateBackupJobCompleted(ctx context.Context, arg UpdateBackupJobCompletedParams) (BackupJob, error) {
	row := q.db.QueryRowContext(ctx, updateBackupJobCompleted, arg.CompletedAt, arg.SizeBytes, arg.ID)
	var i BackupJob
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.TargetType,
		&i.TargetID,
		&i.TargetName,
		&i.ClientID,
		&i.Status,
		&i.Progress,
		&i.Destination,
		&i.SizeBytes,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const updateBackupJobFailed = `-- name: UpdateBackupJobFailed :one
UPDATE backup_jobs
SET status = 'failed', error_message = ?, completed_at = ?
WHERE id = ?
RETURNING id, name, type, target_type, target_id, target_name, client_id, status, progress, destination, size_bytes, error_message, started_at, completed_at, created_by, created_at
`

type UpdateBackupJobFailedParams struct {
	ErrorMessage *string    `json:"error_message"`
	CompletedAt  *time.Time `json:"completed_at"`
	ID           int64      `json:"id"`
}

func (q *Queries) UpdateBackupJobFailed(ctx context.Context, arg UpdateBackupJobFailedParams) (BackupJob, error) {
	row := q.db.QueryRowContext(ctx, updateBackupJobFailed, arg.ErrorMessage, arg.CompletedAt, arg.ID)
	var i BackupJob
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.TargetType,
		&i.TargetID,
		&i.TargetName,
		&i.ClientID,
		&i.Status,
		&i.Progress,
		&i.Destination,
		&i.SizeBytes,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const updateBackupJobProgress = `-- name: UpdateBackupJobProgress :one
UPDATE backup_jobs
SET progress = ?
WHERE id = ?
RETURNING id, name, type, target_type, target_id, target_name, client_id, status, progress, destination, size_bytes, error_message, started_at, completed_at, created_by, created_at
`

type UpdateBackupJobProgressParams struct {
	Progress *int64 `json:"progress"`
	ID       int64  `json:"id"`
}

func (q *Queries) UpdateBackupJobProgress(ctx context.Context, arg UpdateBackupJobProgressParams) (BackupJob, error) {
	row := q.db.QueryRowContext(ctx, updateBackupJobProgress, arg.Progress, arg.ID)
	var i BackupJob
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.TargetType,
		&i.TargetID,
		&i.TargetName,
		&i.ClientID,
		&i.Status,
		&i.Progress,
		&i.Destination,
		&i.SizeBytes,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const updateBackupJobStatus = `-- name: UpdateBackupJobStatus :one
UPDATE backup_jobs
SET status = ?, progress = ?, error_message = ?,
    started_at = COALESCE(started_at, ?),
    completed_at = ?
WHERE id = ?
RETURNING id, name, type, target_type, target_id, target_name, client_id, status, progress, destination, size_bytes, error_message, started_at, completed_at, created_by, created_at
`

type UpdateBackupJobStatusParams struct {
	Status       string     `json:"status"`
	Progress     *int64     `json:"progress"`
	ErrorMessage *string    `json:"error_message"`
	StartedAt    *time.Time `json:"started_at"`
	CompletedAt  *time.Time `json:"completed_at"`
	ID           int64      `json:"id"`
}

func (q *Queries) UpdateBackupJobStatus(ctx context.Context, arg UpdateBackupJobStatusParams) (BackupJob, error) {
	row := q.db.QueryRowContext(ctx, updateBackupJobStatus,
		arg.Status,
		arg.Progress,
		arg.ErrorMessage,
		arg.StartedAt,
		arg.CompletedAt,
		arg.ID,
	)
	var i BackupJob
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.TargetType,
		&i.TargetID,
		&i.TargetName,
		&i.ClientID,
		&i.Status,
		&i.Progress,
		&i.Destination,
		&i.SizeBytes,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const updateBackupSchedule = `-- name: UpdateBackupSchedule :one
UPDATE backup_schedules
SET name = COALESCE(?, name),
    schedule = COALESCE(?, schedule),
    schedule_time = COALESCE(?, schedule_time),
    retention_count = COALESCE(?, retention_count),
    enabled = COALESCE(?, enabled),
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, type, target_type, target_id, target_name, client_id, schedule, schedule_time, destination, retention_count, enabled, last_run_at, next_run_at, last_status, created_by, created_at, updated_at
`

type UpdateBackupScheduleParams struct {
	Name           string  `json:"name"`
	Schedule       string  `json:"schedule"`
	ScheduleTime   *string `json:"schedule_time"`
	RetentionCount *int64  `json:"retention_count"`
	Enabled        *int64  `json:"enabled"`
	ID             int64   `json:"id"`
}

func (q *Queries) UpdateBackupSchedule(ctx context.Context, arg UpdateBackupScheduleParams) (BackupSchedule, error) {
	row := q.db.QueryRowContext(ctx, updateBackupSchedule,
		arg.Name,
		arg.Schedule,
		arg.ScheduleTime,
		arg.RetentionCount,
		arg.Enabled,
		arg.ID,
	)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.TargetType,
		&i.TargetID,
		&i.TargetName,
		&i.ClientID,
		&i.Schedule,
		&i.ScheduleTime,
		&i.Destination,
		&i.RetentionCount,
		&i.Enabled,
		&i.LastRunAt,
		&i.NextRunAt,
		&i.LastStatus,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateScheduleAfterRun = `-- name: UpdateScheduleAfterRun :one
UPDATE backup_schedules
SET last_run_at = ?, next_run_at = ?, last_status = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, type, target_type, target_id, target_name, client_id, schedule, schedule_time, destination, retention_count, enabled, last_run_at, next_run_at, last_status, created_by, created_at, updated_at
`

type UpdateScheduleAfterRunParams struct {
	LastRunAt  *time.Time `json:"last_run_at"`
	NextRunAt  *time.Time `json:"next_run_at"`
	LastStatus *string    `json:"last_status"`
	ID         int64      `json:"id"`
}

func (q *Queries) UpdateScheduleAfterRun(ctx context.Context, arg UpdateScheduleAfterRunParams) (BackupSchedule, error) {
	row := q.db.QueryRowContext(ctx, updateScheduleAfterRun,
		arg.LastRunAt,
		arg.NextRunAt,
		arg.LastStatus,
		arg.ID,
	)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.TargetType,
		&i.TargetID,
		&i.TargetName,
		&i.ClientID,
		&i.Schedule,
		&i.ScheduleTime,
		&i.Destination,
		&i.RetentionCount,
		&i.Enabled,
		&i.LastRunAt,
		&i.NextRunAt,
		&i.LastStatus,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
